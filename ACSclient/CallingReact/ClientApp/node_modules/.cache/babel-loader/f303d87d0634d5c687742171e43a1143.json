{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport React, { useCallback, useState, useMemo, useEffect } from 'react';\nimport { LayerHost, mergeStyles, Stack } from '@fluentui/react';\nimport { CallComposite } from '../CallComposite';\nimport { CallAdapterProvider } from '../CallComposite/adapter/CallAdapterProvider';\nimport { CallWithChatControlBar } from './CallWithChatControlBar';\nimport { callCompositeContainerStyles, compositeOuterContainerStyles, controlBarContainerStyles, drawerContainerStyles, modalLayerHostStyle } from './styles/CallWithChatCompositeStyles';\nimport { CallWithChatBackedCallAdapter } from './adapter/CallWithChatBackedCallAdapter';\nimport { CallWithChatBackedChatAdapter } from './adapter/CallWithChatBackedChatAdapter';\nimport { BaseProvider } from '../common/BaseComposite';\nimport { ChatAdapterProvider } from '../ChatComposite/adapter/ChatAdapterProvider';\nimport { PreparedMoreDrawer } from './PreparedMoreDrawer';\nimport { useId } from '@fluentui/react-hooks';\nimport { CallWithChatPane } from './CallWithChatPane';\n\nconst CallWithChatScreen = props => {\n  const {\n    callWithChatAdapter,\n    fluentTheme,\n    formFactor = 'desktop'\n  } = props;\n  const mobileView = formFactor === 'mobile';\n\n  if (!callWithChatAdapter) {\n    throw new Error('CallWithChatAdapter is undefined');\n  }\n\n  const callAdapter = useMemo(() => new CallWithChatBackedCallAdapter(callWithChatAdapter), [callWithChatAdapter]);\n  const [currentCallState, setCurrentCallState] = useState();\n  const [currentPage, setCurrentPage] = useState();\n  const [activePane, setActivePane] = useState('none');\n  useEffect(() => {\n    const updateCallWithChatPage = newState => {\n      var _a;\n\n      setCurrentPage(newState.page);\n      setCurrentCallState((_a = newState.call) === null || _a === void 0 ? void 0 : _a.state);\n    };\n\n    callWithChatAdapter.onStateChange(updateCallWithChatPage);\n    return () => {\n      callWithChatAdapter.offStateChange(updateCallWithChatPage);\n    };\n  }, [callWithChatAdapter]);\n  const closePane = useCallback(() => {\n    setActivePane('none');\n  }, [setActivePane]);\n  const toggleChat = useCallback(() => {\n    if (activePane === 'chat') {\n      setActivePane('none');\n    } else {\n      setActivePane('chat');\n    }\n  }, [activePane, setActivePane]);\n  const togglePeople = useCallback(() => {\n    if (activePane === 'people') {\n      setActivePane('none');\n    } else {\n      setActivePane('people');\n    }\n  }, [activePane, setActivePane]);\n  const selectChat = useCallback(() => {\n    setActivePane('chat');\n  }, [setActivePane]);\n  const selectPeople = useCallback(() => {\n    setActivePane('people');\n  }, [setActivePane]);\n  const [showDrawer, setShowDrawer] = useState(false);\n  const onMoreButtonClicked = useCallback(() => {\n    closePane();\n    setShowDrawer(true);\n  }, [closePane]);\n  const closeDrawer = useCallback(() => {\n    setShowDrawer(false);\n  }, []);\n  const onMoreDrawerPeopleClicked = useCallback(() => {\n    setShowDrawer(false);\n    togglePeople();\n  }, [togglePeople]);\n  const chatProps = useMemo(() => {\n    return {\n      adapter: new CallWithChatBackedChatAdapter(callWithChatAdapter)\n    };\n  }, [callWithChatAdapter]);\n  const modalLayerHostId = useId('modalLayerhost');\n  const isInLobbyOrConnecting = currentPage === 'lobby';\n  const hasJoinedCall = !!(currentPage && hasJoinedCallFn(currentPage, currentCallState !== null && currentCallState !== void 0 ? currentCallState : 'None'));\n  const showControlBar = isInLobbyOrConnecting || hasJoinedCall;\n  const isMobileWithActivePane = mobileView && activePane !== 'none';\n  return React.createElement(Stack, {\n    verticalFill: true,\n    grow: true,\n    styles: compositeOuterContainerStyles\n  }, React.createElement(Stack, {\n    horizontal: true,\n    grow: true\n  }, !isMobileWithActivePane && React.createElement(Stack.Item, {\n    grow: true,\n    styles: callCompositeContainerStyles\n  }, React.createElement(CallComposite, Object.assign({}, props, {\n    formFactor: formFactor,\n    options: {\n      callControls: false\n    },\n    adapter: callAdapter,\n    fluentTheme: fluentTheme\n  }))), chatProps.adapter && callAdapter && hasJoinedCall && React.createElement(CallWithChatPane, {\n    chatCompositeProps: chatProps,\n    inviteLink: props.joinInvitationURL,\n    onClose: closePane,\n    chatAdapter: chatProps.adapter,\n    callAdapter: callAdapter,\n    onFetchAvatarPersonaData: props.onFetchAvatarPersonaData,\n    onChatButtonClicked: showShowChatTabHeaderButton(props.callControls) ? selectChat : undefined,\n    onPeopleButtonClicked: showShowPeopleTabHeaderButton(props.callControls) ? selectPeople : undefined,\n    modalLayerHostId: modalLayerHostId,\n    mobileView: mobileView,\n    activePane: activePane\n  })), showControlBar && !isMobileWithActivePane && React.createElement(ChatAdapterProvider, {\n    adapter: chatProps.adapter\n  }, React.createElement(Stack.Item, {\n    styles: controlBarContainerStyles\n  }, React.createElement(CallWithChatControlBar, {\n    callAdapter: callAdapter,\n    chatAdapter: chatProps.adapter,\n    chatButtonChecked: activePane === 'chat',\n    onChatButtonClicked: toggleChat,\n    peopleButtonChecked: activePane === 'people',\n    onPeopleButtonClicked: togglePeople,\n    onMoreButtonClicked: onMoreButtonClicked,\n    mobileView: mobileView,\n    disableButtonsForLobbyPage: isInLobbyOrConnecting,\n    callControls: props.callControls\n  }))), showControlBar && showDrawer && React.createElement(ChatAdapterProvider, {\n    adapter: chatProps.adapter\n  }, React.createElement(CallAdapterProvider, {\n    adapter: callAdapter\n  }, React.createElement(Stack, {\n    styles: drawerContainerStyles\n  }, React.createElement(PreparedMoreDrawer, {\n    callControls: props.callControls,\n    onLightDismiss: closeDrawer,\n    onPeopleButtonClicked: onMoreDrawerPeopleClicked\n  })))), // because when the CallWithChatPane is hidden, ie. style property display is 'none', it takes up no space. This causes problems when dragging\n  // the Modal because the draggable bounds thinks it has no space and will always return to its initial position after dragging.\n  mobileView && React.createElement(LayerHost, {\n    id: modalLayerHostId,\n    className: mergeStyles(modalLayerHostStyle)\n  }));\n};\n/**\n * CallWithChatComposite brings together key components to provide a full call with chat experience out of the box.\n *\n * @public\n */\n\n\nexport const CallWithChatComposite = props => {\n  const {\n    adapter,\n    fluentTheme,\n    formFactor,\n    joinInvitationURL,\n    options\n  } = props;\n  return React.createElement(BaseProvider, {\n    fluentTheme: fluentTheme,\n    locale: props.locale,\n    icons: props.icons\n  }, React.createElement(CallWithChatScreen, Object.assign({}, props, {\n    callWithChatAdapter: adapter,\n    formFactor: formFactor,\n    callControls: options === null || options === void 0 ? void 0 : options.callControls,\n    joinInvitationURL: joinInvitationURL,\n    fluentTheme: fluentTheme\n  })));\n};\n\nconst hasJoinedCallFn = (page, callStatus) => page === 'call' && callStatus === 'Connected';\n\nconst showShowChatTabHeaderButton = callControls => {\n  if (callControls === undefined || callControls === true) {\n    return true;\n  }\n\n  if (callControls === false) {\n    return false;\n  }\n\n  return callControls.chatButton !== false;\n};\n\nconst showShowPeopleTabHeaderButton = callControls => {\n  if (callControls === undefined || callControls === true) {\n    return true;\n  }\n\n  if (callControls === false) {\n    return false;\n  }\n\n  return callControls.peopleButton !== false;\n}; //# sourceMappingURL=CallWithChatComposite.js.map","map":null,"metadata":{},"sourceType":"module"}