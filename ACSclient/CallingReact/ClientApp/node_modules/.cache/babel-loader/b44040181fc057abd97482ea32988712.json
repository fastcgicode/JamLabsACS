{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createAzureCommunicationCallAdapter } from '../../CallComposite';\nimport { callWithChatAdapterStateFromBackingStates, mergeCallAdapterStateIntoCallWithChatAdapterState, mergeChatAdapterStateIntoCallWithChatAdapterState } from '../state/CallWithChatAdapterState';\nimport { createAzureCommunicationChatAdapter, createAzureCommunicationChatAdapterFromClient } from '../../ChatComposite/adapter/AzureCommunicationChatAdapter';\nimport { EventEmitter } from 'events';\nimport { getChatThreadFromTeamsLink } from './parseTeamsUrl';\nimport { createAzureCommunicationCallAdapterFromClient } from '../../CallComposite/adapter/AzureCommunicationCallAdapter';\nimport { useEffect, useRef, useState } from 'react';\n/** Context of Call with Chat, which is a centralized context for all state updates */\n\nclass CallWithChatContext {\n  constructor(clientState) {\n    this.emitter = new EventEmitter();\n    this.state = clientState;\n  }\n\n  onStateChange(handler) {\n    this.emitter.on('stateChanged', handler);\n  }\n\n  offStateChange(handler) {\n    this.emitter.off('stateChanged', handler);\n  }\n\n  setState(state) {\n    this.state = state;\n    this.emitter.emit('stateChanged', this.state);\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  updateClientState(clientState) {\n    this.setState(clientState);\n  }\n\n  updateClientStateWithChatState(chatAdapterState) {\n    this.updateClientState(mergeChatAdapterStateIntoCallWithChatAdapterState(this.state, chatAdapterState));\n  }\n\n  updateClientStateWithCallState(callAdapterState) {\n    this.updateClientState(mergeCallAdapterStateIntoCallWithChatAdapterState(this.state, callAdapterState));\n  }\n\n}\n/**\n * CallWithChat adapter backed by Azure Communication Services.\n * Created for easy use with the {@link CallWithChatComposite}.\n */\n\n\nexport class AzureCommunicationCallWithChatAdapter {\n  constructor(callAdapter, chatAdapter) {\n    this.bindPublicMethods();\n    this.callAdapter = callAdapter;\n    this.chatAdapter = chatAdapter;\n    this.context = new CallWithChatContext(callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter));\n\n    const onChatStateChange = newChatAdapterState => {\n      this.context.updateClientStateWithChatState(newChatAdapterState);\n    };\n\n    this.chatAdapter.onStateChange(onChatStateChange);\n    this.onChatStateChange = onChatStateChange;\n\n    const onCallStateChange = newCallAdapterState => {\n      this.context.updateClientStateWithCallState(newCallAdapterState);\n    };\n\n    this.callAdapter.onStateChange(onCallStateChange);\n    this.onCallStateChange = onCallStateChange;\n  }\n\n  bindPublicMethods() {\n    this.joinCall.bind(this);\n    this.leaveCall.bind(this);\n    this.startCall.bind(this);\n    this.onStateChange.bind(this);\n    this.offStateChange.bind(this);\n    this.getState.bind(this);\n    this.dispose.bind(this);\n    this.setCamera.bind(this);\n    this.setMicrophone.bind(this);\n    this.setSpeaker.bind(this);\n    this.askDevicePermission.bind(this);\n    this.queryCameras.bind(this);\n    this.queryMicrophones.bind(this);\n    this.querySpeakers.bind(this);\n    this.startCamera.bind(this);\n    this.stopCamera.bind(this);\n    this.mute.bind(this);\n    this.unmute.bind(this);\n    this.startScreenShare.bind(this);\n    this.stopScreenShare.bind(this);\n    this.removeParticipant.bind(this);\n    this.createStreamView.bind(this);\n    this.disposeStreamView.bind(this);\n    this.fetchInitialData.bind(this);\n    this.sendMessage.bind(this);\n    this.sendReadReceipt.bind(this);\n    this.sendTypingIndicator.bind(this);\n    this.loadPreviousChatMessages.bind(this);\n    this.updateMessage.bind(this);\n    this.deleteMessage.bind(this);\n    this.on.bind(this);\n    this.off.bind(this);\n  }\n  /** Join existing Call. */\n\n\n  joinCall(microphoneOn) {\n    return this.callAdapter.joinCall(microphoneOn);\n  }\n  /** Leave current Call. */\n\n\n  leaveCall() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Only remove self from the GroupCall. Contoso must manage access to Chat.\n      yield this.callAdapter.leaveCall();\n    });\n  }\n  /** Start a new Call. */\n\n\n  startCall(participants) {\n    return this.callAdapter.startCall(participants);\n  }\n  /**\n   * Subscribe to state change events.\n   * @param handler - handler to be called when the state changes. This is passed the new state.\n   */\n\n\n  onStateChange(handler) {\n    this.context.onStateChange(handler);\n  }\n  /**\n   * Unsubscribe to state change events.\n   * @param handler - handler to be no longer called when state changes.\n   */\n\n\n  offStateChange(handler) {\n    this.context.offStateChange(handler);\n  }\n  /** Get current Call and Chat state. */\n\n\n  getState() {\n    return this.context.getState();\n  }\n  /** Dispose of the current CallWithChatAdapter. */\n\n\n  dispose() {\n    this.chatAdapter.offStateChange(this.onChatStateChange);\n    this.callAdapter.offStateChange(this.onCallStateChange);\n    this.chatAdapter.dispose();\n    this.callAdapter.dispose();\n  }\n  /** Remove a participant from the Call only. */\n\n\n  removeParticipant(userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Only remove the participant from the GroupCall. Contoso must manage access to Chat.\n      yield this.callAdapter.removeParticipant(userId);\n    });\n  }\n\n  setCamera(device, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.setCamera(device, options);\n    });\n  }\n  /** Set the microphone to be used in the Call. */\n\n\n  setMicrophone(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.setMicrophone(device);\n    });\n  }\n  /** Set the speaker to be used in the Call. */\n\n\n  setSpeaker(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.setSpeaker(device);\n    });\n  }\n\n  askDevicePermission(constraints) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.askDevicePermission(constraints);\n    });\n  }\n  /** Query for available cameras. */\n\n\n  queryCameras() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.callAdapter.queryCameras();\n    });\n  }\n  /** Query for available microphones. */\n\n\n  queryMicrophones() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.callAdapter.queryMicrophones();\n    });\n  }\n  /** Query for available speakers. */\n\n\n  querySpeakers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.callAdapter.querySpeakers();\n    });\n  }\n  /** Start the camera for the user in the Call. */\n\n\n  startCamera(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.startCamera(options);\n    });\n  }\n  /** Stop the camera for the user in the Call. */\n\n\n  stopCamera() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.stopCamera();\n    });\n  }\n  /** Mute the user in the Call. */\n\n\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.mute();\n    });\n  }\n  /** Unmute the user in the Call. */\n\n\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.unmute();\n    });\n  }\n  /** Trigger the user to start screen share. */\n\n\n  startScreenShare() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.startScreenShare();\n    });\n  }\n  /** Stop the current active screen share. */\n\n\n  stopScreenShare() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.stopScreenShare();\n    });\n  }\n  /** Create a stream view for a remote participants video feed. */\n\n\n  createStreamView(remoteUserId, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.createStreamView(remoteUserId, options);\n    });\n  }\n  /** Dispose of a created stream view of a remote participants video feed. */\n\n\n  disposeStreamView(remoteUserId, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.callAdapter.disposeStreamView(remoteUserId, options);\n    });\n  }\n  /** Fetch initial Call and Chat data such as chat messages. */\n\n\n  fetchInitialData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.chatAdapter.fetchInitialData();\n    });\n  }\n  /** Send a chat message. */\n\n\n  sendMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.chatAdapter.sendMessage(content);\n    });\n  }\n  /** Send a chat read receipt. */\n\n\n  sendReadReceipt(chatMessageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.chatAdapter.sendReadReceipt(chatMessageId);\n    });\n  }\n  /** Send an isTyping indicator. */\n\n\n  sendTypingIndicator() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.chatAdapter.sendTypingIndicator();\n    });\n  }\n  /** Load previous Chat messages. */\n\n\n  loadPreviousChatMessages(messagesToLoad) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.chatAdapter.loadPreviousChatMessages(messagesToLoad);\n    });\n  }\n  /** Update an existing message. */\n\n\n  updateMessage(messageId, content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.chatAdapter.updateMessage(messageId, content);\n    });\n  }\n  /** Delete an existing message. */\n\n\n  deleteMessage(messageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.chatAdapter.deleteMessage(messageId);\n    });\n  }\n\n  on(event, listener) {\n    switch (event) {\n      case 'callParticipantsJoined':\n        this.callAdapter.on('participantsJoined', listener);\n        break;\n\n      case 'callParticipantsLeft':\n        this.callAdapter.on('participantsLeft', listener);\n        break;\n\n      case 'callEnded':\n        this.callAdapter.on('callEnded', listener);\n        break;\n\n      case 'isMutedChanged':\n        this.callAdapter.on('isMutedChanged', listener);\n        break;\n\n      case 'callIdChanged':\n        this.callAdapter.on('callIdChanged', listener);\n        break;\n\n      case 'isLocalScreenSharingActiveChanged':\n        this.callAdapter.on('isLocalScreenSharingActiveChanged', listener);\n        break;\n\n      case 'displayNameChanged':\n        this.callAdapter.on('displayNameChanged', listener);\n        break;\n\n      case 'isSpeakingChanged':\n        this.callAdapter.on('isSpeakingChanged', listener);\n        break;\n\n      case 'messageReceived':\n        this.chatAdapter.on('messageReceived', listener);\n        break;\n\n      case 'messageSent':\n        this.chatAdapter.on('messageSent', listener);\n        break;\n\n      case 'messageRead':\n        this.chatAdapter.on('messageRead', listener);\n        break;\n\n      case 'chatParticipantsAdded':\n        this.chatAdapter.on('participantsAdded', listener);\n        break;\n\n      case 'chatParticipantsRemoved':\n        this.chatAdapter.on('participantsRemoved', listener);\n        break;\n\n      case 'callError':\n        this.callAdapter.on('error', listener);\n        break;\n\n      case 'chatError':\n        this.chatAdapter.on('error', listener);\n        break;\n\n      default:\n        throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;\n    }\n  }\n\n  off(event, listener) {\n    switch (event) {\n      case 'callParticipantsJoined':\n        this.callAdapter.off('participantsJoined', listener);\n        break;\n\n      case 'callParticipantsLeft':\n        this.callAdapter.off('participantsLeft', listener);\n        break;\n\n      case 'callEnded':\n        this.callAdapter.off('callEnded', listener);\n        break;\n\n      case 'isMutedChanged':\n        this.callAdapter.off('isMutedChanged', listener);\n        break;\n\n      case 'callIdChanged':\n        this.callAdapter.off('callIdChanged', listener);\n        break;\n\n      case 'isLocalScreenSharingActiveChanged':\n        this.callAdapter.off('isLocalScreenSharingActiveChanged', listener);\n        break;\n\n      case 'displayNameChanged':\n        this.callAdapter.off('displayNameChanged', listener);\n        break;\n\n      case 'isSpeakingChanged':\n        this.callAdapter.off('isSpeakingChanged', listener);\n        break;\n\n      case 'messageReceived':\n        this.chatAdapter.off('messageReceived', listener);\n        break;\n\n      case 'messageSent':\n        this.chatAdapter.off('messageSent', listener);\n        break;\n\n      case 'messageRead':\n        this.chatAdapter.off('messageRead', listener);\n        break;\n\n      case 'chatParticipantsAdded':\n        this.chatAdapter.off('participantsAdded', listener);\n        break;\n\n      case 'chatParticipantsRemoved':\n        this.chatAdapter.off('participantsRemoved', listener);\n        break;\n\n      case 'callError':\n        this.callAdapter.off('error', listener);\n        break;\n\n      case 'chatError':\n        this.chatAdapter.off('error', listener);\n        break;\n\n      default:\n        throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;\n    }\n  }\n\n}\n/**\n * Create a CallWithChatAdapter backed by Azure Communication services\n * to plug into the {@link CallWithChatComposite}.\n *\n * @public\n */\n\nexport const createAzureCommunicationCallWithChatAdapter = _ref => {\n  let {\n    userId,\n    displayName,\n    credential,\n    endpoint,\n    locator\n  } = _ref;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const callAdapterLocator = isTeamsMeetingLinkLocator(locator) ? locator : locator.callLocator;\n    const createCallAdapterPromise = createAzureCommunicationCallAdapter({\n      userId,\n      displayName,\n      credential,\n      locator: callAdapterLocator\n    });\n    const threadId = isTeamsMeetingLinkLocator(locator) ? getChatThreadFromTeamsLink(locator.meetingLink) : locator.chatThreadId;\n    const createChatAdapterPromise = createAzureCommunicationChatAdapter({\n      endpoint,\n      userId,\n      displayName,\n      credential,\n      threadId\n    });\n    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);\n    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);\n  });\n};\n/**\n * A custom React hook to simplify the creation of {@link CallWithChatAdapter}.\n *\n * Similar to {@link createAzureCommunicationCallWithChatAdapter}, but takes care of asynchronous\n * creation of the adapter internally.\n *\n * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments\n * as they are created. The adapter is only created when all arguments are defined.\n *\n * Note that you must memoize the arguments to avoid recreating adapter on each render.\n * See storybook for typical usage examples.\n *\n * @public\n */\n\nexport const useAzureCommunicationCallWithChatAdapter = (args, afterCreate, beforeDispose) => {\n  const {\n    credential,\n    displayName,\n    endpoint,\n    locator,\n    userId\n  } = args; // State update needed to rerender the parent component when a new adapter is created.\n\n  const [adapter, setAdapter] = useState(undefined); // Ref needed for cleanup to access the old adapter created asynchronously.\n\n  const adapterRef = useRef(undefined);\n  const afterCreateRef = useRef(undefined);\n  const beforeDisposeRef = useRef(undefined); // These refs are updated on *each* render, so that the latest values\n  // are used in the `useEffect` closures below.\n  // Using a Ref ensures that new values for the callbacks do not trigger the\n  // useEffect blocks, and a new adapter creation / distruction is not triggered.\n\n  afterCreateRef.current = afterCreate;\n  beforeDisposeRef.current = beforeDispose;\n  useEffect(() => {\n    if (!credential || !displayName || !endpoint || !locator || !userId) {\n      return;\n    }\n\n    (() => __awaiter(void 0, void 0, void 0, function* () {\n      if (adapterRef.current) {\n        // Dispose the old adapter when a new one is created.\n        //\n        // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of\n        // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter\n        // creation.\n        if (beforeDisposeRef.current) {\n          yield beforeDisposeRef.current(adapterRef.current);\n        }\n\n        adapterRef.current.dispose();\n        adapterRef.current = undefined;\n      }\n\n      let newAdapter = yield createAzureCommunicationCallWithChatAdapter({\n        credential,\n        displayName,\n        endpoint,\n        locator,\n        userId\n      });\n\n      if (afterCreateRef.current) {\n        newAdapter = yield afterCreateRef.current(newAdapter);\n      }\n\n      adapterRef.current = newAdapter;\n      setAdapter(newAdapter);\n    }))();\n  }, // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.\n  [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, locator, userId]); // Dispose any existing adapter when the component unmounts.\n\n  useEffect(() => {\n    return () => {\n      (() => __awaiter(void 0, void 0, void 0, function* () {\n        if (adapterRef.current) {\n          if (beforeDisposeRef.current) {\n            yield beforeDisposeRef.current(adapterRef.current);\n          }\n\n          adapterRef.current.dispose();\n          adapterRef.current = undefined;\n        }\n      }))();\n    };\n  }, []);\n  return adapter;\n};\n/**\n * Create a {@link CallWithChatAdapter} using the provided {@link StatefulChatClient} and {@link StatefulCallClient}.\n *\n * Useful if you want to keep a reference to {@link StatefulChatClient} and {@link StatefulCallClient}.\n * Consider using {@link createAzureCommunicationCallWithChatAdapter} for a simpler API.\n *\n * @public\n */\n\nexport const createAzureCommunicationCallWithChatAdapterFromClients = _ref2 => {\n  let {\n    callClient,\n    callAgent,\n    callLocator,\n    chatClient,\n    chatThreadClient\n  } = _ref2;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const createCallAdapterPromise = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, callLocator);\n    const createChatAdapterPromise = createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);\n    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);\n    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);\n  });\n};\n\nconst isTeamsMeetingLinkLocator = locator => {\n  return 'meetingLink' in locator;\n}; //# sourceMappingURL=AzureCommunicationCallWithChatAdapter.js.map","map":null,"metadata":{},"sourceType":"module"}