{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n\nimport { createStatefulChatClient } from \"../../../../../chat-stateful-client/src\";\nimport { createDefaultChatHandlers } from \"../../../../../chat-component-bindings/src\";\nimport { toFlatCommunicationIdentifier } from \"../../../../../acs-ui-common/src\";\nimport EventEmitter from 'events';\nimport { useEffect, useRef, useState } from 'react';\n/**\n * Context of Chat, which is a centralized context for all state updates\n * @private\n */\n\nexport class ChatContext {\n  constructor(clientState, threadId) {\n    this.emitter = new EventEmitter();\n    const thread = clientState.threads[threadId];\n    this.threadId = threadId;\n\n    if (!thread) {\n      throw 'Cannot find threadId, please initialize thread before use!';\n    }\n\n    this.state = {\n      userId: clientState.userId,\n      displayName: clientState.displayName,\n      thread,\n      latestErrors: clientState.latestErrors\n    };\n  }\n\n  onStateChange(handler) {\n    this.emitter.on('stateChanged', handler);\n  }\n\n  offStateChange(handler) {\n    this.emitter.off('stateChanged', handler);\n  }\n\n  setState(state) {\n    this.state = state;\n    this.emitter.emit('stateChanged', this.state);\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  setError(error) {\n    this.setState(Object.assign(Object.assign({}, this.state), {\n      error\n    }));\n  }\n\n  updateClientState(clientState) {\n    const thread = clientState.threads[this.threadId];\n\n    if (!thread) {\n      throw 'Cannot find threadId, please make sure thread state is still in Stateful ChatClient.';\n    }\n\n    let updatedState = {\n      userId: clientState.userId,\n      displayName: clientState.displayName,\n      thread,\n      latestErrors: clientState.latestErrors\n    };\n    this.setState(updatedState);\n  }\n\n}\n/**\n * @private\n */\n\nexport class AzureCommunicationChatAdapter {\n  constructor(chatClient, chatThreadClient) {\n    this.emitter = new EventEmitter();\n    this.bindAllPublicMethods();\n    this.chatClient = chatClient;\n    this.chatThreadClient = chatThreadClient;\n    this.context = new ChatContext(chatClient.getState(), chatThreadClient.threadId);\n\n    const onStateChange = clientState => {\n      // unsubscribe when the instance gets disposed\n      if (!this) {\n        chatClient.offStateChange(onStateChange);\n        return;\n      }\n\n      this.context.updateClientState(clientState);\n    };\n\n    this.handlers = createDefaultChatHandlers(chatClient, chatThreadClient);\n    this.chatClient.onStateChange(onStateChange);\n    this.subscribeAllEvents();\n  }\n\n  bindAllPublicMethods() {\n    this.onStateChange = this.onStateChange.bind(this);\n    this.offStateChange = this.offStateChange.bind(this);\n    this.getState = this.getState.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.fetchInitialData = this.fetchInitialData.bind(this);\n    this.sendMessage = this.sendMessage.bind(this);\n    this.sendReadReceipt = this.sendReadReceipt.bind(this);\n    this.sendTypingIndicator = this.sendTypingIndicator.bind(this);\n    this.updateMessage = this.updateMessage.bind(this);\n    this.deleteMessage = this.deleteMessage.bind(this);\n    this.removeParticipant = this.removeParticipant.bind(this);\n    this.setTopic = this.setTopic.bind(this);\n    this.loadPreviousChatMessages = this.loadPreviousChatMessages.bind(this);\n    this.on = this.on.bind(this);\n    this.off = this.off.bind(this);\n  }\n\n  dispose() {\n    this.unsubscribeAllEvents();\n  }\n\n  fetchInitialData() {\n    var e_1, _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.chatThreadClient.getProperties();\n      } catch (e) {\n        console.log(e);\n      } // Fetch all participants who joined before the local user.\n\n\n      try {\n        try {\n          for (var _b = __asyncValues(this.chatThreadClient.listParticipants().byPage({\n            // Fetch 100 participants per page by default.\n            maxPageSize: 100 // eslint-disable-next-line curly\n\n          })), _c; _c = yield _b.next(), !_c.done;) {\n            const _page = _c.value;\n            ;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    });\n  }\n\n  getState() {\n    return this.context.getState();\n  }\n\n  onStateChange(handler) {\n    this.context.onStateChange(handler);\n  }\n\n  offStateChange(handler) {\n    this.context.offStateChange(handler);\n  }\n\n  sendMessage(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.handlers.onSendMessage(content, options);\n      }));\n    });\n  }\n\n  sendReadReceipt(chatMessageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.handlers.onMessageSeen(chatMessageId);\n      }));\n    });\n  }\n\n  sendTypingIndicator() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.handlers.onTyping();\n    });\n  }\n\n  removeParticipant(userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.handlers.onRemoveParticipant(userId);\n      }));\n    });\n  }\n\n  setTopic(topicName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.handlers.updateThreadTopicName(topicName);\n      }));\n    });\n  }\n\n  loadPreviousChatMessages(messagesToLoad) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        return yield this.handlers.onLoadPreviousChatMessages(messagesToLoad);\n      }));\n    });\n  }\n\n  updateMessage(messageId, content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        return yield this.handlers.onUpdateMessage(messageId, content);\n      }));\n    });\n  }\n\n  deleteMessage(messageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.asyncTeeErrorToEventEmitter(() => __awaiter(this, void 0, void 0, function* () {\n        return yield this.handlers.onDeleteMessage(messageId);\n      }));\n    });\n  }\n\n  messageReceivedListener(event) {\n    const message = convertEventToChatMessage(event);\n    this.emitter.emit('messageReceived', {\n      message\n    });\n    const currentUserId = toFlatCommunicationIdentifier(this.chatClient.getState().userId);\n\n    if ((message === null || message === void 0 ? void 0 : message.sender) && toFlatCommunicationIdentifier(message.sender) === currentUserId) {\n      this.emitter.emit('messageSent', {\n        message\n      });\n    }\n  }\n\n  messageReadListener(_ref) {\n    let {\n      chatMessageId,\n      recipient\n    } = _ref;\n    const message = this.getState().thread.chatMessages[chatMessageId];\n\n    if (message) {\n      this.emitter.emit('messageRead', {\n        message,\n        readBy: recipient\n      });\n    }\n  }\n\n  participantsAddedListener(_ref2) {\n    let {\n      addedBy,\n      participantsAdded\n    } = _ref2;\n    this.emitter.emit('participantsAdded', {\n      addedBy,\n      participantsAdded\n    });\n  }\n\n  participantsRemovedListener(_ref3) {\n    let {\n      removedBy,\n      participantsRemoved\n    } = _ref3;\n    this.emitter.emit('participantsRemoved', {\n      removedBy,\n      participantsRemoved\n    });\n  }\n\n  chatThreadPropertiesUpdatedListener(event) {\n    this.emitter.emit('topicChanged', {\n      topic: event.properties.topic\n    });\n  }\n\n  subscribeAllEvents() {\n    this.chatClient.on('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));\n    this.chatClient.on('participantsAdded', this.participantsAddedListener.bind(this));\n    this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));\n    this.chatClient.on('chatMessageReceived', this.messageReceivedListener.bind(this));\n    this.chatClient.on('readReceiptReceived', this.messageReadListener.bind(this));\n    this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));\n  }\n\n  unsubscribeAllEvents() {\n    this.chatClient.off('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));\n    this.chatClient.off('participantsAdded', this.participantsAddedListener.bind(this));\n    this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));\n    this.chatClient.off('chatMessageReceived', this.messageReceivedListener.bind(this));\n    this.chatClient.off('readReceiptReceived', this.messageReadListener.bind(this));\n    this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));\n  }\n\n  on(event, listener) {\n    this.emitter.on(event, listener);\n  }\n\n  off(event, listener) {\n    this.emitter.off(event, listener);\n  }\n\n  asyncTeeErrorToEventEmitter(f) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield f();\n      } catch (error) {\n        if (isChatError(error)) {\n          this.emitter.emit('error', error);\n        }\n\n        throw error;\n      }\n    });\n  }\n\n}\n\nconst convertEventToChatMessage = event => {\n  return {\n    id: event.id,\n    version: event.version,\n    content: {\n      message: event.message\n    },\n    type: convertEventType(event.type),\n    sender: event.sender,\n    senderDisplayName: event.senderDisplayName,\n    sequenceId: '',\n    createdOn: new Date(event.createdOn)\n  };\n}; // only text/html message type will be received from event\n\n\nconst convertEventType = type => {\n  const lowerCaseType = type.toLowerCase();\n\n  if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {\n    return 'html';\n  } else {\n    return 'text';\n  }\n};\n/**\n * Create a {@link ChatAdapter} backed by Azure Communication Services.\n *\n * This is the default implementation of {@link ChatAdapter} provided by this library.\n *\n * @public\n */\n\n\nexport const createAzureCommunicationChatAdapter = _ref4 => {\n  let {\n    endpoint: endpointUrl,\n    userId,\n    displayName,\n    credential,\n    threadId\n  } = _ref4;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const chatClient = createStatefulChatClient({\n      userId,\n      displayName,\n      endpoint: endpointUrl,\n      credential: credential\n    });\n    const chatThreadClient = yield chatClient.getChatThreadClient(threadId);\n    yield chatClient.startRealtimeNotifications();\n    const adapter = yield createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);\n    return adapter;\n  });\n};\n/**\n * A custom React hook to simplify the creation of {@link ChatAdapter}.\n *\n * Similar to {@link createAzureCommunicationChatAdapter}, but takes care of asynchronous\n * creation of the adapter internally.\n *\n * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments\n * as they are created. The adapter is only created when all arguments are defined.\n *\n * Note that you must memoize the arguments to avoid recreating adapter on each render.\n * See storybook for typical usage examples.\n *\n * @public\n */\n\nexport const useAzureCommunicationChatAdapter = (args, afterCreate, beforeDispose) => {\n  const {\n    credential,\n    displayName,\n    endpoint,\n    threadId,\n    userId\n  } = args; // State update needed to rerender the parent component when a new adapter is created.\n\n  const [adapter, setAdapter] = useState(undefined); // Ref needed for cleanup to access the old adapter created asynchronously.\n\n  const adapterRef = useRef(undefined);\n  const afterCreateRef = useRef(undefined);\n  const beforeDisposeRef = useRef(undefined); // These refs are updated on *each* render, so that the latest values\n  // are used in the `useEffect` closures below.\n  // Using a Ref ensures that new values for the callbacks do not trigger the\n  // useEffect blocks, and a new adapter creation / distruction is not triggered.\n\n  afterCreateRef.current = afterCreate;\n  beforeDisposeRef.current = beforeDispose;\n  useEffect(() => {\n    if (!credential || !displayName || !endpoint || !threadId || !userId) {\n      return;\n    }\n\n    (() => __awaiter(void 0, void 0, void 0, function* () {\n      if (adapterRef.current) {\n        // Dispose the old adapter when a new one is created.\n        //\n        // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of\n        // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter\n        // creation.\n        if (beforeDisposeRef.current) {\n          yield beforeDisposeRef.current(adapterRef.current);\n        }\n\n        adapterRef.current.dispose();\n        adapterRef.current = undefined;\n      }\n\n      let newAdapter = yield createAzureCommunicationChatAdapter({\n        credential,\n        displayName,\n        endpoint,\n        threadId,\n        userId\n      });\n\n      if (afterCreateRef.current) {\n        newAdapter = yield afterCreateRef.current(newAdapter);\n      }\n\n      adapterRef.current = newAdapter;\n      setAdapter(newAdapter);\n    }))();\n  }, // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.\n  [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, threadId, userId]); // Dispose any existing adapter when the component unmounts.\n\n  useEffect(() => {\n    return () => {\n      (() => __awaiter(void 0, void 0, void 0, function* () {\n        if (adapterRef.current) {\n          if (beforeDisposeRef.current) {\n            yield beforeDisposeRef.current(adapterRef.current);\n          }\n\n          adapterRef.current.dispose();\n          adapterRef.current = undefined;\n        }\n      }))();\n    };\n  }, []);\n  return adapter;\n};\n/**\n * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.\n *\n * Useful if you want to keep a reference to {@link StatefulChatClient}.\n * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.\n *\n * @public\n */\n\nexport const createAzureCommunicationChatAdapterFromClient = (chatClient, chatThreadClient) => __awaiter(void 0, void 0, void 0, function* () {\n  return new AzureCommunicationChatAdapter(chatClient, chatThreadClient);\n});\n\nconst isChatError = e => {\n  return e['target'] !== undefined && e['innerError'] !== undefined;\n}; //# sourceMappingURL=AzureCommunicationChatAdapter.js.map","map":null,"metadata":{},"sourceType":"module"}